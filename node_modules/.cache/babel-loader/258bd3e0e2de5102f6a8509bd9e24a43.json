{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { fromHex, toHex } from \"../util/hex\";\nimport { throwIfCancelled } from \"../util/promises\";\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\n\nvar MAX_BACKFILL_BLOCKS = 120;\n/**\n * The maximum number of requests that can be included in a single batch request.\n * This value is enforced by the backend.\n */\n\nvar MAX_BATCH_SIZE = 10;\nexport function makeBackfiller(jsonRpcSenders) {\n  return {\n    getNewHeadsBackfill: getNewHeadsBackfill,\n    getLogsBackfill: getLogsBackfill\n  };\n\n  function getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, reorgHeads, intermediateHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4\n            /*yield*/\n            , getBlockNumber()];\n\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n\n            if (previousHeads.length === 0) {\n              return [2\n              /*return*/\n              , getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n\n            lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2\n              /*return*/\n              , getHeadEventsInRange(minBlockNumber, toBlockNumber + 1)];\n            }\n\n            return [4\n            /*yield*/\n            , getReorgHeads(isCancelled, previousHeads)];\n\n          case 2:\n            reorgHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [4\n            /*yield*/\n            , getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1)];\n\n          case 3:\n            intermediateHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2\n            /*return*/\n            , __spreadArray(__spreadArray([], __read(reorgHeads)), __read(intermediateHeads))];\n        }\n      });\n    });\n  }\n\n  function getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, i, oldEvent, blockHead;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            result = [];\n            i = previousHeads.length - 1;\n            _a.label = 1;\n\n          case 1:\n            if (!(i >= 0)) return [3\n            /*break*/\n            , 4];\n            oldEvent = previousHeads[i];\n            return [4\n            /*yield*/\n            , getBlockByNumber(fromHex(oldEvent.number))];\n\n          case 2:\n            blockHead = _a.sent();\n            throwIfCancelled(isCancelled);\n\n            if (oldEvent.hash === blockHead.hash) {\n              return [3\n              /*break*/\n              , 4];\n            }\n\n            result.push(toNewHeadsEvent(blockHead));\n            _a.label = 3;\n\n          case 3:\n            i--;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , result.reverse()];\n        }\n      });\n    });\n  }\n\n  function getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var batchParts, headEventBatches, i, batchedBlockHeads, blockHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (fromBlockInclusive >= toBlockExclusive) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            batchParts = [];\n            headEventBatches = [];\n\n            for (i = fromBlockInclusive; i < toBlockExclusive; i++) {\n              batchParts.push({\n                method: \"eth_getBlockByNumber\",\n                params: [toHex(i), false]\n              });\n\n              if (batchParts.length % MAX_BATCH_SIZE === 0) {\n                headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n                batchParts = [];\n              }\n            }\n\n            if (batchParts.length > 0) {\n              headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n            }\n\n            return [4\n            /*yield*/\n            , Promise.all(headEventBatches)];\n\n          case 1:\n            batchedBlockHeads = _a.sent();\n            blockHeads = batchedBlockHeads.reduce(function (acc, batch) {\n              return acc.concat(batch);\n            }, []);\n            return [2\n            /*return*/\n            , blockHeads.map(toNewHeadsEvent)];\n        }\n      });\n    });\n  }\n\n  function getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , jsonRpcSenders.send(\"eth_getBlockByNumber\", [toHex(blockNumber), false])];\n      });\n    });\n  }\n\n  function getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, commonAncestorNumber, removedLogs, addedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4\n            /*yield*/\n            , getBlockNumber()];\n\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n\n            if (previousLogs.length === 0) {\n              return [2\n              /*return*/\n              , getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n\n            lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2\n              /*return*/\n              , getLogsInRange(filter, minBlockNumber, toBlockNumber + 1)];\n            }\n\n            return [4\n            /*yield*/\n            , getCommonAncestorNumber(isCancelled, previousLogs)];\n\n          case 2:\n            commonAncestorNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            removedLogs = previousLogs.filter(function (log) {\n              return fromHex(log.blockNumber) > commonAncestorNumber;\n            }).map(function (log) {\n              return __assign(__assign({}, log), {\n                removed: true\n              });\n            });\n            return [4\n            /*yield*/\n            , getLogsInRange(filter, commonAncestorNumber + 1, toBlockNumber + 1)];\n\n          case 3:\n            addedLogs = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2\n            /*return*/\n            , __spreadArray(__spreadArray([], __read(removedLogs)), __read(addedLogs))];\n        }\n      });\n    });\n  }\n\n  function getCommonAncestorNumber(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var i, _a, blockHash, blockNumber, hash;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            i = previousLogs.length - 1;\n            _b.label = 1;\n\n          case 1:\n            if (!(i >= 0)) return [3\n            /*break*/\n            , 4];\n            _a = previousLogs[i], blockHash = _a.blockHash, blockNumber = _a.blockNumber;\n            return [4\n            /*yield*/\n            , getBlockByNumber(fromHex(blockNumber))];\n\n          case 2:\n            hash = _b.sent().hash;\n            throwIfCancelled(isCancelled);\n\n            if (blockHash === hash) {\n              return [2\n              /*return*/\n              , fromHex(blockNumber)];\n            }\n\n            _b.label = 3;\n\n          case 3:\n            i--;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , Number.NEGATIVE_INFINITY];\n        }\n      });\n    });\n  }\n\n  function getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var rangeFilter;\n      return __generator(this, function (_a) {\n        if (fromBlockInclusive >= toBlockExclusive) {\n          return [2\n          /*return*/\n          , []];\n        }\n\n        rangeFilter = __assign(__assign({}, filter), {\n          fromBlock: toHex(fromBlockInclusive),\n          toBlock: toHex(toBlockExclusive - 1)\n        });\n        return [2\n        /*return*/\n        , jsonRpcSenders.send(\"eth_getLogs\", [rangeFilter])];\n      });\n    });\n  }\n\n  function getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , jsonRpcSenders.send(\"eth_blockNumber\")];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2\n            /*return*/\n            , fromHex(blockNumberHex)];\n        }\n      });\n    });\n  }\n}\n\nfunction toNewHeadsEvent(head) {\n  var result = __assign({}, head);\n\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events) {\n  return dedupe(events, function (event) {\n    return event.hash;\n  });\n}\nexport function dedupeLogs(events) {\n  return dedupe(events, function (event) {\n    return event.blockHash + \"/\" + event.logIndex;\n  });\n}\n\nfunction dedupe(items, getKey) {\n  var keysSeen = new Set();\n  var result = [];\n  items.forEach(function (item) {\n    var key = getKey(item);\n\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}","map":{"version":3,"mappings":"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","names":["fromHex","toHex","throwIfCancelled","MAX_BACKFILL_BLOCKS","MAX_BATCH_SIZE","makeBackfiller","jsonRpcSenders","getNewHeadsBackfill","getLogsBackfill","isCancelled","previousHeads","fromBlockNumber","getBlockNumber","toBlockNumber","_a","length","getHeadEventsInRange","Math","max","lastSeenBlockNumber","number","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","__read","result","i","oldEvent","getBlockByNumber","blockHead","hash","push","toNewHeadsEvent","reverse","fromBlockInclusive","toBlockExclusive","batchParts","headEventBatches","method","params","sendBatch","Promise","all","batchedBlockHeads","blockHeads","reduce","acc","batch","concat","map","blockNumber","send","filter","previousLogs","getLogsInRange","getCommonAncestorNumber","commonAncestorNumber","removedLogs","log","removed","addedLogs","blockHash","_b","Number","NEGATIVE_INFINITY","rangeFilter","fromBlock","toBlock","blockNumberHex","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","logIndex","items","getKey","keysSeen","Set","forEach","item","key","has","add"],"sources":["/Users/markkrasner/Downloads/MDB5-REACT-UI-KIT-Free-4.0.0/node_modules/@alch/alchemy-web3/src/subscriptions/subscriptionBackfill.ts"],"sourcesContent":["import { fromHex, toHex } from \"../util/hex\";\nimport { BatchPart, JsonRpcSenders } from \"../util/jsonRpc\";\nimport { throwIfCancelled } from \"../util/promises\";\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/**\n * The return type of eth_getBlocksByHash.\n */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\ninterface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\nexport type Backfiller = ReturnType<typeof makeBackfiller>;\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The maximum number of requests that can be included in a single batch request.\n * This value is enforced by the backend.\n */\nconst MAX_BATCH_SIZE = 10;\n\nexport function makeBackfiller(jsonRpcSenders: JsonRpcSenders) {\n  return { getNewHeadsBackfill, getLogsBackfill };\n\n  async function getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number,\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousHeads.length === 0) {\n      return getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n    const reorgHeads: NewHeadsEvent[] = await getReorgHeads(\n      isCancelled,\n      previousHeads,\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  async function getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  async function getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    let batchParts: BatchPart[] = [];\n    const headEventBatches: Array<Promise<BlockHead[]>> = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: \"eth_getBlockByNumber\",\n        params: [toHex(i), false],\n      });\n      if (batchParts.length % MAX_BATCH_SIZE === 0) {\n        headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n        batchParts = [];\n      }\n    }\n\n    if (batchParts.length > 0) {\n      headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n    }\n\n    const batchedBlockHeads = await Promise.all(headEventBatches);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      [],\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  async function getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return jsonRpcSenders.send(\"eth_getBlockByNumber\", [\n      toHex(blockNumber),\n      false,\n    ]);\n  }\n\n  async function getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number,\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousLogs.length === 0) {\n      return getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n    const commonAncestorNumber = await getCommonAncestorNumber(\n      isCancelled,\n      previousLogs,\n    );\n    throwIfCancelled(isCancelled);\n    const removedLogs = previousLogs\n      .filter((log) => fromHex(log.blockNumber) > commonAncestorNumber)\n      .map((log) => ({ ...log, removed: true }));\n    const addedLogs = await getLogsInRange(\n      filter,\n      commonAncestorNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  async function getCommonAncestorNumber(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[],\n  ): Promise<number> {\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const { blockHash, blockNumber } = previousLogs[i];\n      const { hash } = await getBlockByNumber(fromHex(blockNumber));\n      throwIfCancelled(isCancelled);\n      if (blockHash === hash) {\n        return fromHex(blockNumber);\n      }\n    }\n    return Number.NEGATIVE_INFINITY;\n  }\n\n  async function getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1),\n    };\n    return jsonRpcSenders.send(\"eth_getLogs\", [rangeFilter]);\n  }\n\n  async function getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await jsonRpcSenders.send(\"eth_blockNumber\");\n    return fromHex(blockNumberHex);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, (event) => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, (event) => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach((item) => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}